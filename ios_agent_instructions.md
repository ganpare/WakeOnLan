# iPhoneアプリ向けリレーエージェント指示書

このドキュメントは、iPhone アプリ（PowerOn）のエージェントが WakeOnLan リレーサーバーへリクエストを送る際の手順とルールをまとめたものです。Tailscale などでリレーサーバーに到達できる前提で記述しています。

## ベース URL

- 例: `http://100.x.y.z:5000`
- 実際にはユーザーの Tailscale IP と設定済みポートを採用すること

## 共通ヘッダー

- `Content-Type: application/json`
- 認証が必要な場合は将来的に `Authorization` を追加予定（現状なし）

## エンドポイント

### 1. Wake（スリープ解除）

- メソッド: `POST /wake`
- Body:
  ```json
  {
    "mac": "00:11:22:33:44:55"
  }
  ```
- フィールド説明:
  - `mac` (必須): Wake-on-LAN 用の MAC アドレス（`mac_address` でも可）

#### レスポンス

**成功時 (200 OK):**
```json
{
  "status": "success"
}
```

**エラー時:**
- **400 Bad Request**: パラメータ不足
  ```json
  {
    "error": "Missing 'mac' parameter"
  }
  ```
- **500 Internal Server Error**: サーバー側エラー

#### エージェント手順

1. 端末設定から `mac` を取得
2. JSON を組み立て `POST /wake` に送信
3. **成功時**: 緑色のチェックマークやトーストで通知
4. **エラー時**: `error` フィールドの内容をユーザーに表示

### 2. Sleep（スリープ指示）

- メソッド: `POST /sleep`
- Body:
  ```json
  {
    "host": "evo-linux",
    "os": "linux",
    "command": "systemctl suspend"
  }
  ```
- フィールド説明:
  - `host` (必須): `ssh host` で接続できるホスト名 or `user@host`（`ip_address` や `ip` でも可）
  - `os` (任意): `linux` / `windows` / `macos`。アプリ側でデフォルトコマンドを切り替える際に利用
  - `command` (任意): カスタムスリープコマンド。指定時は `os` を無視してそのまま実行

#### レスポンス

**成功時 (200 OK):**
```json
{
  "status": "success"
}
```

**エラー時:**
- **400 Bad Request**: パラメータ不足や未対応OS
  ```json
  {
    "error": "Missing 'host' parameter"
  }
  ```
  ```json
  {
    "error": "Unknown OS type and no custom command provided"
  }
  ```

- **502 Bad Gateway**: SSH コマンド実行失敗
  ```json
  {
    "error": "Sleep command failed",
    "details": "Command '['ssh', 'host', 'command']' returned non-zero exit status 127",
    "returncode": 127,
    "command": "ssh host command"
  }
  ```
  - `returncode 127`: コマンド未導入（PATH にない）  
  - `returncode 255`: SSH 接続失敗  
  - その他: `details` を参照

- **500 Internal Server Error**: 予期せぬサーバーエラー

#### エージェント手順

1. 端末設定から `host`（または `ip`）、`os`、`customCommand` を取得
2. アプリ側で OS ごとのデフォルトコマンドをセットし、`customCommand` があれば上書き
3. JSON を組み立て `POST /sleep` に送信
4. **成功時**: 青色の月アイコンなどで通知
5. **エラー時**
   - 400系: `error` の内容をユーザーに表示
   - 502系: `returncode` 別にメッセージを分岐（127=コマンド未導入、255=SSH失敗など）
   - 500系: 「サーバーエラーが発生しました。再試行してください」と案内

> **補足**: サーバー側では `/api/control` エンドポイントも実装されていますが、現在の iOS アプリ実装では `/wake` と `/sleep` を使用しています。既存のアプリとの互換性を保つため、この指示書では `/wake` と `/sleep` をメインに記載しています。

### 3. ヘルスチェック

- メソッド: `GET /healthz` または `GET /health`
- アプリ起動時や設定画面から接続確認に利用

#### レスポンス

**成功時 (200 OK):**
```json
{
  "status": "ok"
}
```

**エラー時:**
- ネットワークエラー: タイムアウトや接続不可
- 404: エンドポイントが存在しない（サーバー設定ミス）

#### エージェント手順

1. アプリ起動時や設定画面でサーバー接続確認
2. **成功時**: サーバー接続状態を「オンライン」として表示（例: 緑色のインジケーター）
3. **エラー時**: サーバー接続状態を「オフライン」として表示（例: 灰色のインジケーター、警告メッセージ）

### 4. ステータス確認（オンライン判定）

- メソッド: `GET /api/status?ip=192.168.1.10&port=22`
- Ping と TCP ポート接続の結果を組み合わせて 3 段階のステータスを返す

#### レスポンス

```json
{
  "ip": "192.168.1.10",
  "port": 22,
  "status": "sleeping",   // online / sleeping / offline
  "ping": true,
  "tcp": false
}
```

- `status: "online"`   → Ping OK & TCP OK
- `status: "sleeping"` → Ping OK & TCP NG（NICのみ稼働）
- `status: "offline"`  → Ping NG
- `port` を省略すると 22 を使用

**エラー時:**
- **400 Bad Request**: IP アドレスやポートの指定が不正

#### エージェント手順

1. マシン一覧画面で各端末の IP アドレス（必要に応じてポート）を取得
2. `GET /api/status?ip=<ip>&port=<port>` を呼び出し
3. **成功時**: 
   - `online` → 緑色の●アイコン
   - `sleeping` → 青色の☾アイコン
   - `offline` → 灰色の●アイコン
4. **エラー時**: ステータス不明（黄色の●アイコン）として扱い、ユーザーに再試行を促す

## 例外・リトライ方針

- 400 系はユーザー設定ミスの可能性が高いためそのままエラー表示
- 500 系/502 は 3 回まで指数バックオフ（1s, 2s, 4s）でリトライ推奨
- ネットワークタイムアウト（5s 以上応答なし）は接続不良として扱い、ユーザーに再試行を促す

## UIエフェクト表示の推奨事項

アプリ側でレスポンスに基づいて適切なエフェクトを表示することで、ユーザー体験を向上させることができます。

### 成功時のエフェクト

- **Wake 成功**: 
  - 緑色のチェックマークアイコン
  - 「起動リクエストを送信しました」などのトーストメッセージ
  - ボタンに一時的な成功アニメーション（例: スケールアニメーション）

- **Sleep 成功**: 
  - 青色の月アイコン
  - 「スリープリクエストを送信しました」などのトーストメッセージ
  - ボタンに一時的な成功アニメーション

- **ステータス確認**: 
  - オンライン: 緑色の●アイコン
  - スリープ中: 青色の☾アイコン（`status: "sleeping"`）
  - オフライン: 灰色の●アイコン
  - 不明: 黄色の●アイコン（エラー時）

### エラー時のエフェクト

- **400 Bad Request**: 
  - 赤色の警告アイコン
  - `error` フィールドの内容をそのまま表示
  - 例: 「MACアドレスが指定されていません」

- **502 Bad Gateway** (Sleep失敗): 
  - 赤色の警告アイコン
  - `returncode` に基づいた分かりやすいメッセージを表示:
    - `returncode 127`: 「コマンドが見つかりません。ホスト側の設定を確認してください」
    - `returncode 255`: 「SSH接続に失敗しました。ホスト名や認証設定を確認してください」
    - その他: `details` の内容を表示
  - `command` フィールドがあれば「実行コマンド: ...」として表示（デバッグ用）

- **500 Internal Server Error**: 
  - 赤色の警告アイコン
  - 「サーバーエラーが発生しました。しばらくしてから再試行してください」

- **ネットワークエラー/タイムアウト**: 
  - 黄色の警告アイコン
  - 「サーバーに接続できません。ネットワーク接続を確認してください」

### ローディング状態

- リクエスト送信中はボタンを無効化し、ローディングインジケーターを表示
- タイムアウトは 5 秒を推奨（サーバー側の処理時間を考慮）

### アニメーション推奨

- 成功時: 0.3-0.5秒のフェードイン/スケールアニメーション
- エラー時: シェイクアニメーション（注意を引くため）
- ステータス更新: スムーズな色変化アニメーション（緑↔青↔灰色、online↔sleeping↔offline）

## 端末設定項目（アプリ側）

| 項目 | 説明 | 必須 |
| --- | --- | --- |
| 名前 | 表示用 | ✔ |
| MAC アドレス | `/wake` 用 | 起動機能を使うなら必須 |
| IP アドレス | `/api/status` & `/sleep` 用 | ステータス表示/スリープで必須 |
| Host | SSH 接続で使いたい別名（任意） | IP と異なる場合のみ |
| OS | `linux` / `windows` / `macos` | スリープ機能を使うなら推奨（デフォルトコマンド選択用） |
| カスタムスリープコマンド | shell コマンド | 任意（指定時はOSのデフォルトより優先） |

### OSごとのデフォルトスリープコマンド（アプリ側で管理推奨）

アプリ側で以下のデフォルトコマンドを管理し、ユーザーがカスタムコマンドを指定していない場合に使用してください：

- **Linux**: `systemctl suspend`
- **Windows**: PowerShell スクリプト（サーバー側デフォルト参照、通常は自動選択）
- **macOS**: `pmset sleepnow`

**注意**: サーバー側にもデフォルトコマンド機能がありますが、アプリ側で管理することで柔軟性が向上し、サーバー側の変更に依存しなくなります。

## セキュリティ/運用ノート

- SSH は中継サーバー上で鍵認証済みであることが前提。パスワード認証は不可
- iPhone から送るリクエストは HTTPS/Tailscale 上で暗号化されるが、今後 `Authorization` ヘッダー追加も検討
- `/sleep` の `command` パラメータは任意シェル実行となるため、ユーザー入力値をそのまま信頼せず、アプリ側でテンプレート化・検証することを推奨
- エラーレスポンスの `details` や `command` フィールドには技術的な情報が含まれるため、一般ユーザー向けには分かりやすいメッセージに変換して表示することを推奨

## 既知の制限

- 同時に複数ホストを操作する場合は、アプリ側でキュー制御を行うこと
- `/wake` と `/sleep` エンドポイントは 1 リクエスト 1 ホストのみ対象

## iOSエージェント実装時の追加推奨事項

### エラーログとデバッグ情報

- **ログ記録**: リクエスト/レスポンスのペイロードをデバッグビルド時のみログ出力することを推奨（本番では個人情報保護のため制限）
- **エラー詳細の保存**: 502 エラーの `returncode` や `command` はユーザーサポート時に有用なため、エラー発生時に一時的に保存しておくことを推奨
- **ネットワーク状態の監視**: `Reachability` や `Network` フレームワークでネットワーク状態を監視し、オフライン時はリクエストを送らないようにする

### パフォーマンスとUX最適化

- **ステータス更新の頻度**: `/api/status` のポーリングは 30-60 秒間隔を推奨。バッテリー消費とリアルタイム性のバランスを考慮
- **バックグラウンド処理**: アプリがバックグラウンドに移行した際は、ステータス更新を一時停止し、フォアグラウンド復帰時に再開
- **リクエストのキャンセル**: ユーザーが画面を離れた場合や操作をキャンセルした場合は、進行中のリクエストをキャンセルして無駄な通信を避ける
- **オフライン時の表示**: ネットワーク未接続時は、キャッシュされた最後のステータスを表示し、「オフライン」バッジを付与

### データ検証とエラーハンドリング

- **入力値の検証**: MAC アドレスや IP アドレスのフォーマットをアプリ側で事前検証し、不正な値はサーバーに送信しない
- **タイムアウト設定**: 各リクエストに適切なタイムアウト（推奨: 5-10秒）を設定し、長時間応答待ちを避ける
- **レスポンスの型安全性**: Swift の `Codable` を活用してレスポンスを型安全にパースし、予期しない形式のレスポンスに備える

### ユーザー体験の向上

- **操作の即時フィードバック**: Wake/Sleep ボタンを押した瞬間にローディング状態を表示し、ユーザーに操作が受け付けられたことを伝える
- **成功/失敗の明確な表示**: トーストやアラートで操作結果を明確に伝え、特に失敗時は再試行ボタンを提供
- **設定の検証**: サーバーURL設定時に `/healthz` で接続確認を行い、設定保存前に検証することを推奨
- **ステータス更新の視覚的フィードバック**: ステータス更新中はスケルトンローディングやプログレスインジケーターを表示

### セキュリティ考慮事項

- **URL スキームの検証**: ユーザーが入力したサーバーURLが正しい形式か検証し、`http://` または `https://` で始まることを確認
- **入力サニタイゼーション**: カスタムコマンド入力時に危険な文字列（`;`, `&&`, `|` など）を検出し、警告を表示
- **認証情報の保存**: 将来的に API キーが導入された場合、Keychain に安全に保存することを推奨

---

この指示書をもとに、エージェントが iPhone アプリから安定してリレーサーバーを操作できるよう実装してください。疑問点があれば README と併せて参照し、必要に応じてフィードバックをもらえると助かります。



